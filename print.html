<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rkyv</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rkyv</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center">
    <img src="https://raw.githubusercontent.com/rkyv/rkyv/master/media/logo_text_color.svg">
</p>
<p><a href="http://github.com/rkyv/rkyv">rkyv</a> (<em>archive</em>) is a zero-copy deserialization framework for
Rust.</p>
<p>This book covers the motivation, architecture, and major features of rkyv. It is the best way to
learn and understand rkyv, but won't go as in-depth on specifics as the documentation will. Don't be
afraid to consult these other resources as you need while you read through.</p>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h2 id="learning-materials"><a class="header" href="#learning-materials">Learning Materials</a></h2>
<ul>
<li>The <a href="https://discord.gg/65F6MdnbQh">rkyv discord</a> is a great place to get help with specific
issues and meet other people using rkyv</li>
<li>The <a href="https://github.com/rkyv/rkyv">rkyv github</a> hosts the source and tracks project issues
and milestones.</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<ul>
<li><a href="https://docs.rs/rkyv">rkyv</a>, the core library</li>
<li><a href="https://docs.rs/rkyv_dyn">rkyv_dyn</a>, which adds trait object support to rkyv</li>
</ul>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<ul>
<li>The <a href="https://github.com/djkoloski/rust_serialization_benchmark">rust serialization benchmark</a> is a
shootout style benchmark comparing many rust serialization solutions. It includes special
benchmarks for zero-copy serialization solutions like rkyv.</li>
</ul>
<h2 id="sister-crates"><a class="header" href="#sister-crates">Sister Crates</a></h2>
<ul>
<li><a href="https://github.com/rkyv/rend">rend</a>, which rkyv uses for endian-agnostic features</li>
<li><a href="https://github.com/rkyv/bytecheck">bytecheck</a>, which rkyv uses for validation</li>
<li><a href="https://github.com/rkyv/rancor">rancor</a>, which rkyv uses for error handling</li>
<li><a href="https://github.com/rkyv/ptr_meta">ptr_meta</a>, which rkyv uses for pointer manipulation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>First and foremost, the motivation behind rkyv is improved performance. The way that it achieves
that goal can also lead to gains in memory use, correctness, and security along the way.</p>
<blockquote>
<p>Familiarity with other serialization frameworks and how traditional serialization works will help,
but isn't necessary to understand how rkyv works.</p>
</blockquote>
<p>Most serialization frameworks like <a href="https://serde.rs">serde</a> define an internal data model that
consists of basic types such as primitives, strings, and byte arrays. This splits the work of
serializing a type into two stages: the frontend and the backend. The frontend takes some type and
breaks it down into the serializable types of the data model. The backend then takes the data model
types and writes them using some data format such as JSON, Bincode, TOML, etc. This allows a clean
separation between the serialization of a type and the data format it is written to.</p>
<blockquote>
<p>Serde describes <a href="https://serde.rs/data-model.html">its data model</a> in the serde book. Everything
serialized with serde eventually boils down to some combination of those types!</p>
</blockquote>
<p>A major downside of traditional serialization is that it takes a considerable amount of time to
read, parse, and reconstruct types from their serialized values.</p>
<blockquote>
<p>In JSON for example, strings are encoded by surrounding the contents with double quotes and
escaping invalid characters inside of them:</p>
<pre><code>{ "line": "\"All's well that ends well\"" }
          ^^                          ^ ^
</code></pre>
<p>numbers are turned into characters:</p>
<pre><code>{ "pi": 3.1415926 }
        ^^^^^^^^^
</code></pre>
<p>and even field names, which could be <em>implicit</em> in most cases, are turned into strings:</p>
<pre><code>{ "message_size": 334 }
  ^^^^^^^^^^^^^^^
</code></pre>
<p>All those characters are not only taking up space, they're also taking up time. Every time we read
and parse JSON, we're picking through those characters in order to figure out what the values are
and reproduce them in memory. An <code>f32</code> is only four bytes of memory, but it's encoded using nine
bytes and we still have to turn those nine characters into the right <code>f32</code>!</p>
</blockquote>
<p>This deserialization time adds up quickly, and in data-heavy applications such as games and media
editing it can come to dominate load times. rkyv provides a solution through a serialization
technique called <em>zero-copy deserialization</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-copy-deserialization"><a class="header" href="#zero-copy-deserialization">Zero-copy deserialization</a></h1>
<p>Zero-copy deserialization is a technique that reduces the time and memory required to access and use
data by <em>directly referencing bytes in the serialized form</em>.</p>
<blockquote>
<p>This takes advantage of how we have to have some data loaded in memory in order to deserialize it.
If we had some JSON:</p>
<pre><code>{ "quote": "I don't know, I didn't listen." }
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Instead of copying those characters into a <code>String</code>, we could just <em>borrow</em> it from the JSON
buffer as a <code>&amp;str</code>. The lifetime of that <code>&amp;str</code> would depend on our buffer and we wouldn't be
allowed to drop it until we had dropped the string we were using.</p>
</blockquote>
<h2 id="partial-zero-copy"><a class="header" href="#partial-zero-copy">Partial zero-copy</a></h2>
<p>Serde and others have support for partial zero-copy deserialization, where bits and pieces of the
deserialized data are borrowed from the serialized form. Strings, for example, can borrow their
bytes directly from the serialized form in encodings like bincode that don't perform any character
escaping. However, a string object must still be created to hold the deserialized length and point
to the borrowed characters.</p>
<blockquote>
<p>A good way to think about this is that even though we're borrowing lots of data from the buffer,
we still have to parse the <em>structure</em> out:</p>
<pre><code class="language-rs">struct Example&lt;'a&gt; {
  quote: &amp;'a str,
  a: &amp;'a [u8; 12],
  b: u64,
  c: char,
}
</code></pre>
<p>So a buffer might break down like this:</p>
<pre><code>I don't know, I didn't listen.AAAAAAAAAAAABBBBBBBBCCCC
^-----------------------------^-----------^-------^---
 quote: str                    a: [u8; 12] b: u64  c: char
</code></pre>
<p>We do a lot less work, but we still have to parse, create, and return an <code>Example&lt;'a&gt;</code>:</p>
<pre><code class="language-rs">Example {
  quote: str::from_utf8(&amp;buffer[0..30]).unwrap(),
  a: &amp;buffer[30..42],
  b: u64::from_le_bytes(&amp;buffer[42..50]),
  c: char::from_u32(u32::from_le_bytes(&amp;buffer[50..54]))).unwrap(),
}
</code></pre>
<p>And we can't borrow types like <code>u64</code> or <code>char</code> that have alignment requirements since our buffer
might not be properly aligned. We have to immediately parse and store those! Even though we
borrowed 42 of the buffer's bytes, we missed out on the last 12 and still had to parse through the
buffer to find out where everything is.</p>
</blockquote>
<p>Partial zero-copy deserialization can considerably improve memory usage and often speed up
some deserialization, but with some work we can go further.</p>
<h2 id="total-zero-copy"><a class="header" href="#total-zero-copy">Total zero-copy</a></h2>
<p>rkyv implements total zero-copy deserialization, which guarantees that no data is copied during
deserialization and no work is done to deserialize data. It achieves this by structuring its encoded
representation so that it is the same as the in-memory representation of the source type.</p>
<blockquote>
<p>This is more like if our buffer <em>was</em> an Example:</p>
<pre><code class="language-rs">struct Example {
  quote: String,
  a: [u8; 12],
  b: u64,
  c: char,
}
</code></pre>
<p>And our buffer looked like this:</p>
<pre><code>I don't know, I didn't listen.__QOFFQLENAAAAAAAAAAAABBBBBBBBCCCC
^-----------------------------  ^---^---^-----------^-------^---
 quote bytes                    pointer  a           b       c
                                and len
                                ^-------------------------------
                                 Example
</code></pre>
<p>In this case, the bytes are padded to the correct alignment and the fields of <code>Example</code> are laid
out exactly the same as they would be in memory. Our deserialization code can be much simpler:</p>
<pre><code class="language-rs">unsafe { &amp;*buffer.as_ptr().add(32).cast() }
</code></pre>
<p>This operation is almost zero work, and more importantly it doesn't <em>scale</em> with our data. No
matter how much or how little data we have, it's always just a pointer offset and a cast to access
our data.</p>
</blockquote>
<p>This opens up blazingly-fast data loading and enables data access orders of magnitude more quickly
than traditional serialization.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The core of rkyv is built around relative pointers and three core
traits: <code>Archive</code>, <code>Serialize</code>, and <code>Deserialize</code>. Each of these traits has a
corresponding variant that supports unsized types: <code>ArchiveUnsized</code>,
<code>SerializeUnsized</code>, and <code>DeserializeUnsized</code>.</p>
<blockquote>
<p>A good way to think about it is that sized types are the <em>foundation</em> that unsized types are built
on. That's not a fluke either, rkyv is built precisely so that you can build more complex
abstractions out of lower-level machinery in a safe and composable way. It's not much different
from what you normally do while programming!</p>
</blockquote>
<p>The system is built to be flexible and can be extended beyond the provided types. For example, the
<code>rkyv_dyn</code> crate adds support for trait objects by introducing new traits and defining how they
build up to allow trait objects to be serialized and deserialized.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relative-pointers"><a class="header" href="#relative-pointers">Relative pointers</a></h1>
<p>Relative pointers are the bread and butter of total zero-copy deserialization, completely replacing
the use of normal pointers. But why can't we use normal pointers?</p>
<p>Consider some zero-copy data on disk. Before we can use it, we need to load it into memory. But we
can't control <em>where</em> in memory it gets loaded. Every time we load it, it could be located at a
different address, and therefore the objects inside of it will be located at a different address.</p>
<blockquote>
<p>One of the major reasons for this is actually <em>security</em>. Every time you run your program, it may
run in a completely different random location in memory. This is called
<a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">address space layout randomization</a>
and it helps prevent exploitation of memory corruption vulnerabilities.</p>
<p>At most, we can only control the <em>alignment</em> of our zero-copy data, so we need to work within
those constraints.</p>
</blockquote>
<p>This means that we can't store any pointers to that data, inside of it or outside of it. As soon as
we reload the data, it might not be at the same address. That would leave our pointers dangling, and
would almost definitely result in memory access violations. Some other libraries like
<a href="https://github.com/TimelyDataflow/abomonation">abomonation</a> store some extra data and perform a
fast fixup step that takes the place of deserialization, but we can do better.</p>
<blockquote>
<p>In order to perform that fixup step, abomonation requires that the buffer has a <em>mutable backing</em>.
This is okay for many use cases, but there are also cases where we won't be able to mutate our
buffer. One example is if we used
<a href="https://en.wikipedia.org/wiki/Memory-mapped_file">memory-mapped files</a>.</p>
</blockquote>
<p>While normal pointers hold an absolute address in memory, relative pointers hold an offset to an address. This changes how
the pointer behaves under moves:</p>
<div class="table-wrapper"><table><thead><tr><th>Pointer</th><th>Self is moved</th><th>Self and target are moved</th></tr></thead><tbody>
<tr><td>Absolute</td><td>✅ Target is still at address</td><td>❌ Target no longer at address</td></tr>
<tr><td>Relative</td><td>❌ Relative distance has changed</td><td>✅ Self and target same relative distance apart</td></tr>
</tbody></table>
</div>
<p>This is exactly the property we need to build data structures with total zero-copy deserialization.
By using relative pointers, we can load data at any position in memory and still have valid pointers
inside of it. Relative pointers don't require write access to memory either, so we can memory map
entire files and instantly have access to their data in a structured manner.</p>
<p>rkyv's implementation of relative pointers is the <code>RelPtr</code> type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive"><a class="header" href="#archive">Archive</a></h1>
<p>Types that implement <code>Archive</code> have an alternate representation that supports zero-copy
deserialization. The construction of archived types happens in two steps:</p>
<ol>
<li>Any dependencies of the type are serialized. For strings this would be the characters of the
string, for boxes it would be the boxed value, and for vectors it would be any contained elements.
Any bookkeeping from this step is bundled into a <code>Resolver</code> type and held onto for later. This is
the <em>serialize</em> step.</li>
<li>The resolver and original value are used to construct the archived value in the output buffer.
For strings the resolver would be the position of the characters, for boxes it would be the position
of the boxed value, and for vectors it would be the position of the archived elements. With the
original values and resolvers combined, the archived version can be constructed. This is the
<em>resolve</em> step.</li>
</ol>
<h2 id="resolvers"><a class="header" href="#resolvers">Resolvers</a></h2>
<p>A good example of why resolvers are necessary is when archiving a tuple. Say we have two strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = ("hello".to_string(), "world".to_string());
<span class="boring">}</span></code></pre></pre>
<p>The archived tuple needs to have both of the strings right next to each other:</p>
<pre><code>0x0000      AA AA AA AA BB BB BB BB
0x0008      CC CC CC CC DD DD DD DD
</code></pre>
<p>A and B might be the length and pointer for the first string of the tuple, and C and D might be the
length and pointer for the second string.</p>
<p>When archiving, we might be tempted to serialize and resolve the first string, then serialize and
resolve the second one. But this might place the second string's bytes ("world") between the two!
Instead, we need to write out the bytes for both strings, and then finish archiving both of them.
The tuple doesn't know what information the strings need to finish archiving themselves, so they
have to provide it to the tuple through their Resolver.</p>
<p>This way, the tuple can:</p>
<ol>
<li>Archive the first string (save the resolver)</li>
<li>Archive the second string (save the resolver)</li>
<li>Resolve the first string with its resolver</li>
<li>Resolve the second string with its resolver</li>
</ol>
<p>And we're guaranteed that the two strings are placed right next to each other like we need.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialize"><a class="header" href="#serialize">Serialize</a></h1>
<p>Types implement <code>Serialize</code> separately from <code>Archive</code>. <code>Serialize</code> creates a resolver for some
object, then <code>Archive</code> turns the value and that resolver into an archived type. Having a separate
<code>Serialize</code> trait is necessary because although a type may have only one archived representation,
it may support many different types of <em>serializers</em> which fulfill its requirements.</p>
<blockquote>
<p>The <code>Serialize</code> trait is parameterized over the <em>serializer</em>. The serializer is just a mutable
object that helps the type serialize itself. The most basic types like <code>u32</code> or <code>char</code> don't
<em>bound</em> their serializer type because they can serialize themselves with any kind of serializer.
More complex types like <code>Box</code> and <code>String</code> require a serializer that implements <code>Writer</code>, and even
more complex types like <code>Rc</code> and <code>Vec</code> require a serializer that additionally implements <code>Sharing</code>
or <code>Allocator</code>.</p>
</blockquote>
<p>Unlike <code>Serialize</code>, <code>Archive</code> doesn't parameterize over the serializer used to make it. It shouldn't
matter what serializer a resolver was made with, only that it's made correctly.</p>
<h2 id="serializer"><a class="header" href="#serializer">Serializer</a></h2>
<p>rkyv provides default serializers which can serialize all standard library types, as well as
components which can be combined into custom-built serializers. By combining rkyv's provided
components, serializers can be customized for high-performance, no-std, and custom allocation.</p>
<p>When using the high-level API, a <code>HighSerializer</code> provides a good balance of flexibility and
performance by default. When using the low-level API, a <code>LowSerializer</code> does the same without any
allocations. You can make custom serializers using the <code>Serializer</code> combinator, or by writing your
own from scratch.</p>
<p>rkyv comes with a few primary serializer traits built-in:</p>
<h3 id="positional"><a class="header" href="#positional">Positional</a></h3>
<p>This core serializer trait provides positional information during serialization. Because types need
to know the relative distance between objects, the <code>Positional</code> trait provides the current position
of the "write head" of the serializer. Resolvers will often store the <em>position</em> of some serialized
data so that a relative pointer can be calculated to it during <code>resolve</code>.</p>
<h3 id="writer"><a class="header" href="#writer">Writer</a></h3>
<p><code>Writer</code> accepts byte slices and writes them to some output. It is similar to the standard library's
<code>Write</code> trait, but rkyv's <code>Writer</code> trait works in no-std contexts. In rkyv, writers are always
<em>write-forward</em> - they never backtrack and rewrite data later. This makes it possible for writers to
eagerly sink bytes to disk or the network without having to first buffer the entire message.</p>
<p>Several kinds of <code>Writer</code>s are supported by default:</p>
<ul>
<li><code>Vec&lt;u8&gt;</code></li>
<li><code>AlignedVec</code>, which is a highly-aligned vector of bytes. This is the writer rkyv uses by default
in most cases.</li>
<li><code>Buffer</code>, which supports no-std use cases (for example, writing into fixed-size stack memory).</li>
<li>Types which implement <code>std::io::Write</code> can be adapted into a <code>Writer</code> by wrapping them in the
<code>IoWriter</code> type.</li>
</ul>
<h3 id="allocator"><a class="header" href="#allocator">Allocator</a></h3>
<p>Many types require temporarily-allocated space during serialization. This space is used temporarily,
and then returned to the serializer before serialization finishes. For example, <code>Vec</code> might request
a dynamically-sized allocation to store the resolvers for its elements until it finishes serializing
all of them. Allocating memory from the serializer allows the same bytes to be efficiently reused
many times, which reduces the number of slow memory allocations performed during serialization.</p>
<h3 id="sharing"><a class="header" href="#sharing">Sharing</a></h3>
<p>rkyv serializes shared pointers like <code>Rc</code> and <code>Arc</code> and can control whether they are de-duplicated.
The <code>Sharing</code> trait provides some mutable state on the serializer which keeps track of which shared
pointers have been serialized so far, and can instruct repeated shared pointers to point to a
previously-serialized instance. This also allows rkyv to preserve shared pointers during zero-copy
access and deserialization.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deserialize"><a class="header" href="#deserialize">Deserialize</a></h1>
<p>Similarly to <code>Serialize</code>, <code>Deserialize</code> parameterizes over a deserializer, and converts a type from
its archived form back to its original one. Unlike serialization, deserialization occurs in a single
step and doesn't have an equivalent of a resolver.</p>
<blockquote>
<p><code>Deserialize</code> also parameterizes over the type that is being deserialized into. This allows the
same archived type to deserialize into multiple different unarchived types depending on what's
being asked for. This helps enable lots of very powerful abstractions, but might require you to
use a turbofish or annotate types when deserializing.</p>
</blockquote>
<p>This provides a more or less traditional deserialization with the added benefit of being sped up
by having very compiler-friendly representations. It also incurs both the memory and performance
penalties of traditional deserialization, so make sure that it's what you need before you use it.
Deserialization is not required to access archived data as long as you can do so through the
archived versions.</p>
<blockquote>
<p>Even the highest-performance serialization frameworks will hit a deserialization speed limit
because of the amount of memory allocation that needs to be performed.</p>
</blockquote>
<p>A good use for <code>Deserialize</code> is deserializing small portions of archives. You can easily traverse
the archived data to locate some subobject, then deserialize just that piece instead of the archive
as a whole. This granular approach provides the benefits of both zero-copy deserialization as well
as traditional deserialization.</p>
<h2 id="pooling"><a class="header" href="#pooling">Pooling</a></h2>
<p>Deserializers, like serializers, provide capabilities to objects during deserialization. Most types
don't need to bound their deserializers, but some like <code>Rc</code> require special traits in order to
deserialize properly.</p>
<p>The <code>Pooling</code> trait controls how pointers which were serialized shared are deserialized. Much like
<code>Sharing</code>, <code>Pooling</code> holds some mutable state on the deserializer to allow shared pointers to the
same data to coordinate with each other. Using the <code>Pool</code> implementation pools these deserialized
shared pointers together, whereas <code>Unpool</code> clones them for each instance of the shared pointer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format"><a class="header" href="#format">Format</a></h1>
<p>Types which derive <code>Archive</code> generate an archived version of the type where:</p>
<ul>
<li>Member types are replaced with their archived counterparts</li>
<li>Structs are <code>#[repr(C)]</code>.</li>
<li>Enums have <code>#[repr(N)]</code> where N is <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, or <code>u128</code>, choosing the smallest
possible type that can represent all of the variants.</li>
<li>All primitives are replaced with versions which have stable, well-defined layouts and byte orders.</li>
</ul>
<p>For example, a struct like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Example {
    a: u32,
    b: String,
    c: Box&lt;(u32, String)&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Would have the archived counterpart:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct ArchivedExample {
    a: u32_le,
    b: ArchivedString,
    c: ArchivedBox&lt;ArchivedTuple2&lt;u32_le, ArchivedString&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>With the <code>little_endian</code> feature enabled.</p>
<p>rkyv provides <code>Archive</code> implementations for common standard library types by default. In general,
they follow the same format as derived implementations but may differ in some cases. For example,
<code>ArchivedString</code> performs a small string optimization which helps reduce memory use.</p>
<h2 id="format-control"><a class="header" href="#format-control">Format control</a></h2>
<p>rkyv provides sets of feature flags which control the basic properties of archived primitives:</p>
<ul>
<li>Endianness: <code>little_endian</code>/<code>big_endian</code> control the endianness of the underlying data</li>
<li>Alignment: <code>aligned</code>/<code>unaligned</code> control whether primitive types have alignment greater than 1.</li>
<li>Pointer width: <code>pointer_width_16</code>/<code>pointer_width_32</code>/<code>pointer_width_64</code> control the size of
relative pointer offsets. This allows trading off space for a larger maximum buffer size.</li>
</ul>
<p>When left unspecified, rkyv chooses these defaults for format control:</p>
<ul>
<li>Little-endian</li>
<li>Aligned</li>
<li>32-bit relative pointers</li>
</ul>
<h2 id="object-order"><a class="header" href="#object-order">Object order</a></h2>
<p>rkyv lays out subobjects in depth-first order from the leaves to the root. This means that the root
object is stored at the end of the buffer, not the beginning. For example, this tree:</p>
<pre><code>  a
 / \
b   c
   / \
  d   e
</code></pre>
<p>would be laid out like this in the buffer:</p>
<pre><code>b d e c a
</code></pre>
<p>from this serialization order:</p>
<pre><code>a -&gt; b
a -&gt; c -&gt; d
a -&gt; c -&gt; e
a -&gt; c
a
</code></pre>
<p>This deterministic layout means that you don't need to store the position of the root object in most
cases. As long as your buffer ends right at the end of your root object, you can use <code>access</code> with
your buffer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alignment"><a class="header" href="#alignment">Alignment</a></h1>
<p>The <em>alignment</em> of a type restricts where it can be located in memory to optimize hardware loads and
stores. Because rkyv creates references to values located in your serialized bytes, it has to ensure
that the references it creates are properly <em>aligned</em> for the type.</p>
<blockquote>
<p>In order to perform arithmetic and logical operations on data, modern CPUs need to <em>load</em> that
data from memory into its registers. However, there's usually a hardware limitation on how the CPU
can access that data: it can only access data starting at <em>word boundaries</em>. These words are the
natural size for the CPU to work with; the word size is 4 bytes for 32-bit machines and 8 bytes
for 64-bit machines. Imagine we had some data laid out like this:</p>
<pre><code>0   4   8   C
AAAABBBBCCCCDDDD
</code></pre>
<p>On a 32-bit CPU, accesses could occur at any address that's a multiple of 4 bytes. For example,
one could access <code>A</code> by loading 4 bytes from address 0, <code>B</code> by loading 4 bytes from address 4, and
so on. This works great because our data is <em>aligned</em> to word boundaries. <em>Unaligned</em> data can
throw a wrench in that:</p>
<pre><code>0   4   8   C
..AAAABBBBCCCC
</code></pre>
<p>Now if we want to load <code>A</code> into memory, we have to:</p>
<ol>
<li>Load 4 bytes from address 0</li>
<li>Throw away the first two bytes</li>
<li>Load 4 bytes from address 4</li>
<li>Throw away the last two bytes</li>
<li>Combine our four bytes together</li>
</ol>
<p>That forces us to do twice as many loads <em>and</em> perform some correction logic. That can have a real
impact on our performance across the board, so we require all of our data to be properly aligned.</p>
</blockquote>
<p>rkyv provides two main utilities for aligning byte buffers:</p>
<ul>
<li><code>AlignedVec</code>, a higher-aligned drop-in replacement for <code>Vec&lt;u8&gt;</code></li>
<li><code>Align</code>, a wrapper type which aligns its field to a 16-byte boundary</li>
</ul>
<p>For most use cases, 16-aligned memory should be sufficient.</p>
<h2 id="in-practice"><a class="header" href="#in-practice">In practice</a></h2>
<p>rkyv's unchecked APIs have very basic alignment checks which always run in debug builds. These may
not catch every case, but using <a href="format/../validation.html">validation</a> will always make sure that your data
is properly aligned.</p>
<h3 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common pitfalls</a></h3>
<p>In some cases, your archived data may be prefixed by some extra data like the length of the buffer.
If this extra data misaligns the following data, then the buffer will have to have the prefixing
data removed before accessing it.</p>
<p>In other cases, your archived data may not be tight to the end of the buffer. Functions like
<code>access</code> rely on the end of the buffer being tight to the end of the data, and may miscalculate the
position of the archived data if it is not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-macro-features"><a class="header" href="#derive-macro-features">Derive macro features</a></h1>
<p>rkyv's derive macro supports a number of attributes and configurable options. All of rkyv's macro
attributes are documented on the <code>Archive</code> proc-macro. Some of the most important ones to know are:</p>
<h2 id="omit_bounds"><a class="header" href="#omit_bounds"><code>omit_bounds</code></a></h2>
<p>rkyv's derive macro performs a "perfect derive" by default. This means that when it generates trait
impls, it adds where clauses requiring each field type to also implement that trait. This can cause
trouble in two primary situations:</p>
<ol>
<li>Recursive type definitions (using e.g. <code>Box</code>) cause an overflow and never finish evaluating</li>
<li>Private types may be exposed by these derive bounds.</li>
</ol>
<p>Both of these situations can be fixed by adding <code>#[rkyv(omit_bounds)]</code> on the field. This prevents
rkyv from adding the "perfect derive" bounds for that field.</p>
<p>When you do omit the bounds for a particular field, it can lead to insufficient bounds being added
to the generated impl. To add custom bounds back, you can use:</p>
<ul>
<li><code>#[rkyv(archive_bounds(..))]</code> to add predicates to all generated impls</li>
<li><code>#[rkyv(serialize_bounds(..))]</code> to add predicates to just the <code>Serialize</code> impl</li>
<li><code>#[rkyv(deserialize_bounds(..))]</code> to add predicates to just the <code>Deserialize</code> impl</li>
</ul>
<p>See <code>rkyv/examples/json_like_schema.rs</code> for a fully-commented example of using <code>omit_bounds</code>.</p>
<h2 id="with--"><a class="header" href="#with--"><code>with = ..</code></a></h2>
<p>This customizes the serialization of a field by applying a
<a href="derive-macro-features/wrapper-types.html">wrapper type</a>.</p>
<h2 id="remote--"><a class="header" href="#remote--"><code>remote = ..</code></a></h2>
<p>This performs a <a href="derive-macro-features/remote-derive.html">remote derive</a> for supporting external
types.</p>
<h2 id="attr-and-derive"><a class="header" href="#attr-and-derive"><code>attr(..)</code> and <code>derive(..)</code></a></h2>
<p><code>#[rkyv(attr(..))]</code> is a general-purpose attribute which allows you to pass attributes down to the
generated archived type. This can be especially useful in combination with <code>#[rkyv(derive(..))]</code>,
which may be used on types and is sugar for <code>#[rkyv(attr(derive(..)))]</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapper-types"><a class="header" href="#wrapper-types">Wrapper types</a></h1>
<p>Wrapper types customize the way that fields of types are archived. In some cases, wrapper types
merely change the default behavior to a preferred alternative. In other cases, wrapper types allow
serializing types which do not have support for rkyv by default.</p>
<p>Annotating a field with <code>#[rkyv(with = ..)]</code> will <em>wrap</em> that field with the given types when the
struct is serialized or deserialized. There's no performance penalty to wrapping types, but doing
more or less work during serialization and deserialization can affect performance. This excerpt is
from the documentation for <code>ArchiveWith</code>:</p>
<pre><code class="language-rs">#[derive(Archive, Deserialize, Serialize)]
struct Example {
    #[rkyv(with = Incremented)]
    a: i32,
    // Another i32 field, but not incremented this time
    b: i32,
}
</code></pre>
<p>The <code>Incremented</code> wrapper is wrapping <code>a</code>, and the definition causes that field to be incremented
in its archived form.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="remote-derive"><a class="header" href="#remote-derive">Remote derive</a></h1>
<p>Like serde, rkyv also supports <em>remote derive</em>. This allows you to easily generate wrapper types to
serialize types from other crates which don't provide rkyv support. Remote derive uses a local
definition of the type to serialize, and generates a wrapper type you can use to serialize that
type.</p>
<p>Remote derive supports getters, wrapper types, and deserialization back to the original type by
providing a <code>From</code> impl. This example is from <code>rkyv/examples/remote_types.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Let's create a local type that will serve as `with`-wrapper for `Foo`.
// Fields must have the same name and type but it's not required to define all
// fields.
#[derive(Archive, Serialize, Deserialize)]
#[rkyv(remote = remote::Foo)] // &lt;-
#[rkyv(archived = ArchivedFoo)]
// ^ not necessary but we might as well replace the default name
// `ArchivedFooDef` with `ArchivedFoo`.
struct FooDef {
    // The field's type implements `Archive` and we don't want to apply any
    // conversion for the archived type so we don't need to specify
    // `#[rkyv(with = ..)]`.
    ch: char,
    // The field is private in the remote type so we need to specify a getter
    // to access it. Also, its type doesn't implement `Archive` so we need
    // to specify a `with`-wrapper too.
    #[rkyv(getter = remote::Foo::bar, with = BarDef)]
    bar: remote::Bar&lt;i32&gt;,
    // The remote `bytes` field is public but we can still customize our local
    // field when using a getter.
    #[rkyv(getter = get_first_byte)]
    first_byte: u8,
}

fn get_first_byte(foo: &amp;remote::Foo) -&gt; u8 {
    foo.bytes[0]
}

// Deriving `Deserialize` with `remote = ..` requires a `From` implementation.
impl From&lt;FooDef&gt; for remote::Foo {
    fn from(value: FooDef) -&gt; Self {
        remote::Foo::new(value.ch, [value.first_byte, 2, 3, 4], 567, value.bar)
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-pointers"><a class="header" href="#shared-pointers">Shared Pointers</a></h1>
<p>The implementation details of shared pointers may be of interest to those using them. The rules
surrounding how and when shared and weak pointers are serialized and pooled may affect how you
choose to use them.</p>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<p>Shared pointers (<code>Rc</code> and <code>Arc</code>) are serialized whenever they're encountered for the first time, and
the data address is reused when subsequent shared pointers point to the same data. This means that
you can expect shared pointers to always point to the same value when archived, even if they are
unsized to different types.</p>
<p>Weak pointers (<code>rc::Weak</code> and <code>sync::Weak</code>) have serialization attempted as soon as they're
encountered. The serialization process upgrades them, and if it succeeds it serializes them like
shared pointers. Otherwise, it serializes them like <code>None</code>.</p>
<h2 id="deserialization"><a class="header" href="#deserialization">Deserialization</a></h2>
<p>Similarly, shared pointers are deserialized on the first encounter and reused afterward. Weak
pointers do a similar upgrade attempt when they're encountered for the first time.</p>
<h2 id="serializers-and-deserializers"><a class="header" href="#serializers-and-deserializers">Serializers and Deserializers</a></h2>
<p>The serializers for shared pointers hold the location of the serialized data. This means it's safe
to serialize shared pointers to an archive across multiple <code>serialize</code> calls as long as you use the
same serializer for each one. Using a new serializer will still do the right thing, but may end up
duplicating the shared data.</p>
<p>The deserializers for shared pointers hold a shared pointer to any deserialized values, and will
hold them in memory until the deserializer is dropped. This means that if you serialize only weak
pointers to some shared data, they will point to the correct value when deserialized but will point
to nothing as soon as the deserializer is dropped.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsized-types"><a class="header" href="#unsized-types">Unsized Types</a></h1>
<p>rkyv supports unsized types out of the box and ships with implementations for the most common
unsized types (<code>str</code>s and slices). Trait objects can also be supported with <code>rkyv_dyn</code>, see
<a href="trait-objects.html">Trait Objects</a> for more details.</p>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>The core concept that enables unsized types is metadata. In rust, pointers to types can be different
sizes, in contrast with languages like C and C++ where all pointers are the same size. This is
important for the concept of sizing, which you may have encountered through rust's
<a href="https://doc.rust-lang.org/std/marker/trait.Sized.html">Sized</a> trait.</p>
<p>Pointers are composed of two pieces: a data address and some metadata. The data address is what most
people think of when they think about pointers; it's the location of the pointed-to data. The
metadata for a pointer is extra data that's needed to work safely with the data at the pointed-to
location. It can be almost anything, or nothing at all for <code>Sized</code> types. Pointers with no extra
metadata are sometimes called "narrow" pointers, and pointers <em>with</em> metadata are sometimes called
"wide" pointers.</p>
<blockquote>
<p>rkyv uses the <a href="https://docs.rs/ptr_meta"><code>ptr_meta</code></a> crate to perform these conversions safely. In
the future, these may be incorporated as
<a href="https://rust-lang.github.io/rfcs/2580-ptr-meta.html">part of the standard library</a>.</p>
</blockquote>
<p>Fundamentally, the metadata of a pointer exists to provide the program enough information to safely
access, drop, and deallocate structures that are pointed to. For slices, the metadata carries the
length of the slice, for trait objects it carries the virtual function table (vtable) pointer, and
for custom unsized structs it carries the metadata of the single trailing unsized member.</p>
<h2 id="archived-metadata"><a class="header" href="#archived-metadata">Archived Metadata</a></h2>
<p>For unsized types, the metadata for a type is archived separately from the relative pointer to the
data. This mirrors how rust works internally to support archiving shared pointers and other exotic
use cases. This does complicate things somewhat, but for most people the metadata archiving process
will end up as just filling out a few functions and returning <code>()</code>.</p>
<blockquote>
<p>This is definitely one of the more complicated parts of the library, and can be difficult to wrap
your head around. Reading the documentation for <code>ArchiveUnsized</code> may help you understand how the
system works by working through an example.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-objects"><a class="header" href="#trait-objects">Trait Objects</a></h1>
<p>Trait object serialization is supported through the <code>rkyv_dyn</code> crate. This crate is maintained as
part of rkyv, but is separate from the main crate to allow other implementations to be used instead.
This section will focus primarily on the architecture of <code>rkyv_dyn</code> and how to use it effectively.</p>
<blockquote>
<p><code>rkyv_dyn</code> may not work in some exotic environments due to the ✨magic✨ it uses to register
trait objects. If you want these capabilities but <code>rkyv_dyn</code> doesn't work in your environment,
feel free to file an issue or drop by in the discord to talk it through.</p>
</blockquote>
<h2 id="core-traits"><a class="header" href="#core-traits">Core traits</a></h2>
<p>The new traits introduced by <code>rkyv_dyn</code> are
<a href="https://docs.rs/rkyv_dyn/latest/rkyv_dyn/trait.SerializeDyn.html"><code>SerializeDyn</code></a> and
<a href="https://docs.rs/rkyv_dyn/latest/rkyv_dyn/trait.DeserializeDyn.html"><code>DeserializeDyn</code></a>. These are
effectively type-erased versions of <code>SerializeUnsized</code> and <code>DeserializeUnsized</code> so that the traits
are object-safe. Likewise, it introduces type-erased versions of serializers and deserializers:
<a href="https://docs.rs/rkyv_dyn/latest/rkyv_dyn/trait.DynSerializer.html"><code>DynSerializer</code></a> and
<a href="https://docs.rs/rkyv_dyn/latest/rkyv_dyn/trait.DynDeserializer.html"><code>DynDeserializer</code></a>. These
attempt to provide the basic functionality required to serialize most types, but may be more or less
capable than custom types require.</p>
<blockquote>
<p><code>DynSerializer</code> implements the <code>Serializer</code> and <code>ScratchSpace</code> traits, but that may not be
suitable for all use cases. If you need more capabilities, file an issue or drop by in the discord
to talk it through.</p>
</blockquote>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<p>It is highly recommended to use the provided
<a href="https://docs.rs/rkyv_dyn/latest/rkyv_dyn/attr.archive_dyn.html"><code>archive_dyn</code></a> macro to implement
the new traits and set everything up correctly.</p>
<p>Using <code>archive_dyn</code> on a trait definition creates another trait definition with supertraits of your
trait and <code>SerializeDyn</code>. This "shim" trait is blanket implemented for all types that implement your
trait and <code>SerializeDyn</code>, so you should only ever have to implement your trait to use it.</p>
<p>The shim trait should be used everywhere that you have a trait object of your trait that you want to
serialize. By default, it will be named "Serialize" + your trait name. A different approach that
similar libraries take is directly adding <code>SerializeDyn</code> as a supertrait of your trait. While more
ergonomic, this approach does not allow the implementation of the trait on types that cannot or
should not implement <code>SerializeDyn</code>, so the shim trait approach was favored for <code>rkyv_dyn</code>.</p>
<p>When the shim trait is serialized, it stores the type hash of the underlying type in its metadata so
it can get the correct vtable for it when accessed. This requires that all vtables for implementing
types must be known ahead of time, which is when we use <code>archive_dyn</code> for the second time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation"><a class="header" href="#validation">Validation</a></h1>
<p>Validation can be enabled with the <code>bytecheck</code> feature, and leverages the
<a href="https://docs.rs/bytecheck"><code>bytecheck</code></a> crate to perform archive validation. This allows the
use of untrusted and malicious data.</p>
<p>If the <code>bytecheck</code> feature is enabled, then rkyv will automatically derive
<a href="https://docs.rs/bytecheck/latest/bytecheck/trait.CheckBytes.html"><code>CheckBytes</code></a> for your archived
type:</p>
<pre><code class="language-rs">use rkyv::{Archive, Deserialize, Serialize};

#[derive(Archive, Deserialize, Serialize)]
pub struct Example {
    a: i32,
    b: String,
    c: Vec&lt;bool&gt;,
}
</code></pre>
<p>The <code>#[rkyv(bytecheck(..))]</code> attribute passes its arguments through to the underlying <code>CheckBytes</code>
derive on the archived type. Finally, you can use <code>access</code> to check an archive and get a reference
to the archived value if it was successful:</p>
<pre><code class="language-rs">use rkyv::{access, rancor::Failure};

let archived_example = access::&lt;ArchivedExample, Failure&gt;(buffer).unwrap();
</code></pre>
<h2 id="the-validation-context"><a class="header" href="#the-validation-context">The validation context</a></h2>
<p>When checking an archive, a validation context is created automatically using some good defaults
that will work for most archived types. If your type requires special validation logic, you may need
to augment the capabilities of the validation context in order to check your type.</p>
<h2 id="bounds-checking-and-subtree-ranges"><a class="header" href="#bounds-checking-and-subtree-ranges">Bounds checking and subtree ranges</a></h2>
<p>All pointers are checked to make sure that they:</p>
<ul>
<li>Point inside the archive</li>
<li>Are properly aligned</li>
<li>And have enough space afterward to hold the desired object</li>
</ul>
<p>However, this alone is not enough to secure against recursion attacks and memory sharing violations,
so rkyv uses a system to verify that the archive follows its strict ownership model.</p>
<p>Archive validation uses a memory model where all subobjects are located in contiguous memory. This
is called a <em>subtree range</em>. When validating an object, the archive context keeps track of where
subobjects are allowed to be located, and can reduce the subtree range from the beginning by pushing
a new subtree range. After pushing a subtree range, any subobjects in that range can be checked by
calling their <code>CheckBytes</code> implementations. Once the subobjects are checked, the subtree range can
be popped to restore the original range with the checked section removed.</p>
<h2 id="validation-and-shared-pointers"><a class="header" href="#validation-and-shared-pointers">Validation and Shared Pointers</a></h2>
<p>While validating shared pointers is supported, some additional restrictions are in place to prevent
malicious data from validating.</p>
<p>Shared pointers that point to the same object will fail to validate if they are different types.
This can cause issues if you have a shared pointer to the same array, but the pointers are an array
pointer and a slice pointer. Similarly, it can cause issues if you have shared pointers to the same
value as a concrete type (e.g. <code>i32</code>) and a trait object (e.g. <code>dyn Any</code>).</p>
<p>rkyv still supports these use cases, but it's not possible or feasible to ensure data integrity with
these use cases. Alternative validation solutions like archive signatures and data hashes may be a
better approach in these cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allocation-tracking"><a class="header" href="#allocation-tracking">Allocation tracking</a></h1>
<p>rkyv's provided <code>AllocationTracker</code> struct wraps an <code>Allocator</code> and tracks when memory is allocated
and freed during serialization. It can also calculate synthetic metrics, like the minimum amount of
pre-allocated memory required to serialize a value. And, it can report the maximum alignment of all
serialized types.</p>
<p>You can create a custom serializer with allocation tracking by calling <code>Serializer::new(..)</code> and
providing the pieces of your serializer. Normally, the provided allocator would be an <code>ArenaHandle</code>,
but instead you should provide it an <code>AllocationTracker::new(arena_handle)</code>.</p>
<p>After serializing your value, the serializer can be decomposed with <code>into_raw_parts</code>. You can then
retrieve the <code>AllocationStats</code> from the allocator by calling <code>into_stats</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-comparison"><a class="header" href="#feature-comparison">Feature Comparison</a></h1>
<p>This is a best-effort feature comparison between rkyv, FlatBuffers, and Cap'n Proto. This is by no
means completely comprehensive, and pull requests that improve this are welcomed.</p>
<h2 id="feature-matrix"><a class="header" href="#feature-matrix">Feature matrix</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>rkyv</th><th>Cap'n Proto</th><th>FlatBuffers</th></tr></thead><tbody>
<tr><td>Open type system</td><td>yes</td><td>no</td><td>no</td></tr>
<tr><td>Scalars</td><td>yes</td><td>no</td><td>yes</td></tr>
<tr><td>Tables</td><td>no</td><td>yes</td><td>yes</td></tr>
<tr><td>Schema evolution</td><td>no</td><td>yes</td><td>yes</td></tr>
<tr><td>Zero-copy</td><td>yes</td><td>yes</td><td>yes</td></tr>
<tr><td>Random-access reads</td><td>yes</td><td>yes</td><td>yes</td></tr>
<tr><td>Validation</td><td>upfront</td><td>on-demand</td><td>yes</td></tr>
<tr><td>Reflection</td><td>no</td><td>yes</td><td>yes</td></tr>
<tr><td>Object order</td><td>bottom-up</td><td>either</td><td>bottom-up</td></tr>
<tr><td>Schema language</td><td>derive</td><td>custom</td><td>custom</td></tr>
<tr><td>Usable as mutable state</td><td>limited</td><td>limited</td><td>limited</td></tr>
<tr><td>Padding takes space on wire?</td><td>optional</td><td>optional</td><td>no</td></tr>
<tr><td>Unset fields take space on wire?</td><td>yes</td><td>yes</td><td>no</td></tr>
<tr><td>Pointers take space on wire?</td><td>yes</td><td>yes</td><td>yes</td></tr>
<tr><td>Cross-language</td><td>no</td><td>yes</td><td>yes</td></tr>
<tr><td>Hash maps and B-trees</td><td>yes</td><td>no</td><td>no</td></tr>
<tr><td>Shared pointers</td><td>yes</td><td>no</td><td>no</td></tr>
</tbody></table>
</div>
<p>Although these features aren't supported out-of-the-box, rkyv's open type system allows extensions
which provide many of these capabilities.</p>
<h2 id="open-type-system"><a class="header" href="#open-type-system">Open type system</a></h2>
<p>One of rkyv's primary features is that its type system is <em>open</em>. This means that users can write
custom types and control their properties very finely. You can think of rkyv as a solid foundation
to build many other features on top of. In fact, the open type system is already a fundamental part
of how rkyv works.</p>
<h3 id="unsized-types-1"><a class="header" href="#unsized-types-1">Unsized types</a></h3>
<p>Even though they're part of the main library, unsized types are built on top of the core
serialization functionality. Types like <code>Box</code> and <code>Rc/Arc</code> that can hold unsized types are entry
points for unsized types into the sized system.</p>
<h3 id="trait-objects-1"><a class="header" href="#trait-objects-1">Trait objects</a></h3>
<p>Trait objects are further built on top of unsized types to make serializing and using trait objects
easy and safe.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<p>Because it's so different from traditional serialization systems, a lot of people have questions
about rkyv. This is meant to serve as a comprehensive, centralized source for answers.</p>
<h2 id="how-is-rkyv-zero-copy-it-definitely-copies-the-archive-into-memory"><a class="header" href="#how-is-rkyv-zero-copy-it-definitely-copies-the-archive-into-memory">How is rkyv zero-copy? It definitely copies the archive into memory.</a></h2>
<p>Traditional serialization works in two steps:</p>
<ol>
<li>Read the data from disk into a buffer (maybe in pieces)</li>
<li>Process the data in the buffer into the deserialized data structure</li>
</ol>
<p>The copy happens in the second step, when the data in the buffer ends up duplicated in the final
data structure. Zero-copy deserialization doesn't deserialize the buffer into a separate structure,
and thus avoids this copy.</p>
<p>Advanced techniques like memory-mapped files can also help you avoid copying as much of your data if
you only read smaller parts of it.</p>
<h2 id="how-does-rkyv-handle-endianness"><a class="header" href="#how-does-rkyv-handle-endianness">How does rkyv handle endianness?</a></h2>
<p>rkyv supports little- and big-endian formats. You can enable specific endiannesses with the
<code>little_endian</code> and <code>big_endian</code> features, or default to little-endian byte ordering.</p>
<h2 id="is-rkyv-cross-platform"><a class="header" href="#is-rkyv-cross-platform">Is rkyv cross-platform?</a></h2>
<p>Yes.</p>
<h2 id="can-i-use-this-in-embedded-and-no_std-environments"><a class="header" href="#can-i-use-this-in-embedded-and-no_std-environments">Can I use this in embedded and <code>#[no_std]</code> environments?</a></h2>
<p>Yes, disable the <code>std</code> feature for <code>no_std</code>. You can additionally disable the <code>alloc</code> feature to
disable all memory allocation capabilities.</p>
<h1 id="safety"><a class="header" href="#safety">Safety</a></h1>
<h2 id="isnt-this-very-unsafe-if-you-access-untrusted-data"><a class="header" href="#isnt-this-very-unsafe-if-you-access-untrusted-data">Isn't this very unsafe if you access untrusted data?</a></h2>
<p>If you skip validation, then yes. You can still access untrusted data if you validate the archive
first with bytecheck. It's an extra step, but it's usually still less than the cost of deserializing
using a traditional format.</p>
<h2 id="doesnt-that-mean-i-always-have-to-validate"><a class="header" href="#doesnt-that-mean-i-always-have-to-validate">Doesn't that mean I always have to validate?</a></h2>
<p>No, there are many other ways you can verify your data, for example with checksums and cryptographic
signatures.</p>
<h2 id="isnt-it-kind-of-deceptive-to-say-rkyv-is-fast-and-then-require-validation"><a class="header" href="#isnt-it-kind-of-deceptive-to-say-rkyv-is-fast-and-then-require-validation">Isn't it kind of deceptive to say rkyv is fast and then require validation?</a></h2>
<p>The fastest path to access archived data is marked as <code>unsafe</code>. This doesn't mean that it's
unusable, it means that it's only safe to call if you can verify its preconditions.</p>
<p>As long as you can reasonably uphold those preconditions, then accessing the archive is safe. Not
every archive needs to be validated, and you can use a variety of different techniques to guarantee
data integrity and security.</p>
<p>Even if you do need to always validate your data before accessing it, validation is still faster
than deserializing with other high-performance formats. A round-trip is still faster, even though
it's not by the same margins.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Thanks to all the contributors who have helped document rkyv:</p>
<ul>
<li>David Koloski (<a href="https://github.com/djkoloski">djkoloski</a>)</li>
<li>Badewanne3 (<a href="https://github.com/MaxOhn">MaxOhn</a>)</li>
</ul>
<p>If you feel you're missing from this list, feel free to add yourself in a PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
