<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rkyv</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="rkyv.html">rkyv</a></li><li class="chapter-item expanded affix "><li class="part-title">Foundations</li><li class="chapter-item expanded "><a href="motivation.html"><strong aria-hidden="true">1.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="zero-copy-deserialization.html"><strong aria-hidden="true">2.</strong> Zero-copy deserialization</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/relative-pointers.html"><strong aria-hidden="true">3.1.</strong> Relative pointers</a></li><li class="chapter-item expanded "><a href="architecture/archive.html"><strong aria-hidden="true">3.2.</strong> Archive</a></li><li class="chapter-item expanded "><a href="architecture/serialize.html"><strong aria-hidden="true">3.3.</strong> Serialize</a></li><li class="chapter-item expanded "><a href="architecture/deserialize.html"><strong aria-hidden="true">3.4.</strong> Deserialize</a></li><li class="chapter-item expanded "><a href="architecture/alignment.html"><strong aria-hidden="true">3.5.</strong> Alignment</a></li></ol></li><li class="chapter-item expanded "><a href="format.html"><strong aria-hidden="true">4.</strong> Format</a></li><li class="chapter-item expanded "><a href="wrapper-types.html"><strong aria-hidden="true">5.</strong> Wrapper types</a></li><li class="chapter-item expanded "><a href="shared-pointers.html"><strong aria-hidden="true">6.</strong> Shared pointers</a></li><li class="chapter-item expanded "><a href="unsized-types.html"><strong aria-hidden="true">7.</strong> Unsized types</a></li><li class="chapter-item expanded "><a href="trait-objects.html"><strong aria-hidden="true">8.</strong> Trait objects</a></li><li class="chapter-item expanded "><a href="validation.html"><strong aria-hidden="true">9.</strong> Validation</a></li><li class="chapter-item expanded "><a href="feature-comparison.html"><strong aria-hidden="true">10.</strong> Feature comparison</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">11.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced rkyv</li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Validation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Serializer composition</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Alternative writers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Extending serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Hybrid deserialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Effective wrapper types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Archived vs unarchived types</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">18.1.</strong> Impl duplication</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> Streaming serialization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Schema evolution</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> Nightly features</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">21.1.</strong> Copy optimization</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Derive macro features</div></li><li class="chapter-item expanded affix "><a href="contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rkyv</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center">
    <img src="https://raw.githubusercontent.com/rkyv/rkyv/master/media/logo_text_color.svg">
</p>
<p><a href="http://github.com/rkyv/rkyv">rkyv</a> (<em>archive</em>) is a zero-copy deserialization framework for
rust.</p>
<p>This book covers the motivation, architecture, and major features of rkyv. It is the best way to
learn and understand rkyv, but won't go as in-depth on specifics as the documentation will. Don't be
afraid to consult these other resources as you need while you read through.</p>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h2 id="learning-materials"><a class="header" href="#learning-materials">Learning Materials</a></h2>
<ul>
<li>The <a href="https://discord.gg/65F6MdnbQh">rkyv discord</a> is a great place to get help with specific
issues and meet other people using rkyv</li>
<li>The <a href="https://github.com/rkyv/rkyv">rkyv github</a> hosts the source and tracks project issues
and milestones.</li>
</ul>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<ul>
<li><a href="https://docs.rs/rkyv">rkyv</a>, the core library</li>
<li><a href="https://docs.rs/rkyv_dyn">rkyv_dyn</a>, which adds trait object support to rkyv</li>
<li><a href="https://docs.rs/rkyv_typename">rkyv_typename</a>, a type naming library</li>
</ul>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<ul>
<li>The <a href="https://github.com/djkoloski/rust_serialization_benchmark">rust serialization benchmark</a> is a
shootout style benchmark comparing many rust serialization solutions. It includes special
benchmarks for zero-copy serialization solutions like rkyv.</li>
</ul>
<h2 id="sister-crates"><a class="header" href="#sister-crates">Sister Crates</a></h2>
<ul>
<li><a href="https://github.com/rkyv/bytecheck">bytecheck</a>, which rkyv uses for validation</li>
<li><a href="https://github.com/rkyv/ptr_meta">ptr_meta</a>, which rkyv uses for pointer manipulation</li>
<li><a href="https://github.com/rkyv/rend">rend</a>, which rkyv uses for endian-agnostic features</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>First and foremost, the motivation behind rkyv is improved performance. The way that it achieves
that goal can also lead to gains in memory use, correctness, and security along the way.</p>
<blockquote>
<p>Familiarity with other serialization frameworks and how traditional serialization works will help,
but isn't necessary to understand how rkyv works.</p>
</blockquote>
<p>Most serialization frameworks like <a href="https://serde.rs">serde</a> define an internal data model that
consists of basic types such as primitives, strings, and byte arrays. This splits the work of
serializing a type into two stages: the frontend and the backend. The frontend takes some type and
breaks it down into the serializable types of the data model. The backend then takes the data model
types and writes them using some data format such as JSON, Bincode, TOML, etc. This allows a clean
separation between the serialization of a type and the data format it is written to.</p>
<blockquote>
<p>Serde describes <a href="https://serde.rs/data-model.html">its data model</a> in the serde book. Everything
serialized with serde eventually boils down to some combination of those types!</p>
</blockquote>
<p>A major downside of traditional serialization is that it takes a considerable amount of time to
read, parse, and reconstruct types from their serialized values.</p>
<blockquote>
<p>In JSON for example, strings are encoded by surrounding the contents with double quotes and
escaping invalid characters inside of them:</p>
<pre><code>{ &quot;line&quot;: &quot;\&quot;All's well that ends well\&quot;&quot; }
          ^^                          ^ ^
</code></pre>
<p>numbers are turned into characters:</p>
<pre><code>{ &quot;pi&quot;: 3.1415926 }
        ^^^^^^^^^
</code></pre>
<p>and even field names, which could be <em>implicit</em> in most cases, are turned into strings:</p>
<pre><code>{ &quot;message_size&quot;: 334 }
  ^^^^^^^^^^^^^^^
</code></pre>
<p>All those characters are not only taking up space, they're also taking up time. Every time we read
and parse JSON, we're picking through those characters in order to figure out what the values are
and reproduce them in memory. An <code>f32</code> is only four bytes of memory, but it's encoded using nine
bytes and we still have to turn those nine characters into the right <code>f32</code>!</p>
</blockquote>
<p>This deserialization time adds up quickly, and in data-heavy applications such as games and media
editing it can come to dominate load times. rkyv provides a solution through a serialization
technique called <em>zero-copy deserialization</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-copy-deserialization"><a class="header" href="#zero-copy-deserialization">Zero-copy deserialization</a></h1>
<p>Zero-copy deserialization is a technique that reduces the time and memory required to access and use
data by <em>directly referencing bytes in the serialized form</em>.</p>
<blockquote>
<p>This takes advantage of how we have to have some data loaded in memory in order to deserialize it.
If we had some JSON:</p>
<pre><code>{ &quot;quote&quot;: &quot;I don't know, I didn't listen.&quot; }
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Instead of copying those characters into a <code>String</code>, we could just <em>borrow</em> it from the JSON
buffer as a <code>&amp;str</code>. The lifetime of that <code>&amp;str</code> would depend on our buffer and we wouldn't be
allowed to drop it until we had dropped the string we were using.</p>
</blockquote>
<h2 id="partial-zero-copy"><a class="header" href="#partial-zero-copy">Partial zero-copy</a></h2>
<p>Serde and others have support for partial zero-copy deserialization, where bits and pieces of the
deserialized data are borrowed from the serialized form. Strings, for example, can borrow their
bytes directly from the serialized form in encodings like bincode that don't perform any character
escaping. However, a string object must still be created to hold the deserialized length and point
to the borrowed characters.</p>
<blockquote>
<p>A good way to think about this is that even though we're borrowing lots of data from the buffer,
we still have to parse the <em>structure</em> out:</p>
<pre><code class="language-rs">struct Example&lt;'a&gt; {
  quote: &amp;'a str,
  a: &amp;'a [u8; 12],
  b: u64,
  c: char,
}
</code></pre>
<p>So a buffer might break down like this:</p>
<pre><code>I don't know, I didn't listen.AAAAAAAAAAAABBBBBBBBCCCC
^-----------------------------^-----------^-------^---
 quote: str                    a: [u8; 12] b: u64  c: char
</code></pre>
<p>We do a lot less work, but we still have to parse, create, and return an <code>Example&lt;'a&gt;</code>:</p>
<pre><code class="language-rs">Example {
  quote: str::from_utf8(&amp;buffer[0..30]).unwrap(),
  a: &amp;buffer[30..42],
  b: u64::from_le_bytes(&amp;buffer[42..50]),
  c: char::from_u32(u32::from_le_bytes(&amp;buffer[50..54]))).unwrap(),
}
</code></pre>
<p>And we can't borrow types like <code>u64</code> or <code>char</code> that have alignment requirements since our buffer
might not be properly aligned. We have to immediately parse and store those! Even though we
borrowed 42 of the buffer's bytes, we missed out on the last 12 and still had to parse through the
buffer to find out where everything is.</p>
</blockquote>
<p>Partial zero-copy deserialization can considerably improve memory usage and often speed up
some deserialiation, but with some work we can go further.</p>
<h2 id="total-zero-copy"><a class="header" href="#total-zero-copy">Total zero-copy</a></h2>
<p>rkyv implements total zero-copy deserialization, which guarantees that no data is copied during
deserialization and no work is done to deserialize data. It achieves this by structuring its encoded
representation so that it is the same as the in-memory representation of the source type.</p>
<blockquote>
<p>This is more like if our buffer <em>was</em> an Example:</p>
<pre><code class="language-rs">struct Example {
  quote: String,
  a: [u8; 12],
  b: u64,
  c: char,
}
</code></pre>
<p>And our buffer looked like this:</p>
<pre><code>I don't know, I didn't listen.__QOFFQLENAAAAAAAAAAAABBBBBBBBCCCC
^-----------------------------  ^---^---^-----------^-------^---
 quote bytes                    pointer  a           b       c
                                and len
                                ^-------------------------------
                                 Example
</code></pre>
<p>In this case, the bytes are padded to the correct alignment and the fields of <code>Example</code> are laid
out exactly the same as they would be in memory. Our deserialization code can be much simpler:</p>
<pre><code class="language-rs">unsafe { &amp;*buffer.as_ptr().add(32).cast() }
</code></pre>
<p>This operation is almost zero work, and more importantly it doesn't <em>scale</em> with our data. No
matter how much or how little data we have, it's always just a pointer offset and a cast to access
our data.</p>
</blockquote>
<p>This opens up blazingly-fast data loading and enables data access orders of magnitude more quickly
than traditional serialization.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The core of rkyv is built around
<a href="https://docs.rs/rkyv/0.7.1/rkyv/rel_ptr/struct.RelPtr.html">relative pointers</a> and three core
traits:
<a href="https://docs.rs/rkyv/0.7.1/rkyv/trait.Archive.html"><code>Archive</code></a>,
<a href="https://docs.rs/rkyv/0.7.1/rkyv/trait.Serialize.html"><code>Serialize</code></a>, and
<a href="https://docs.rs/rkyv/0.7.1/rkyv/trait.Deserialize.html"><code>Deserialize</code></a>. Each of these traits has a
corresponding variant that supports unsized types:
<a href="https://docs.rs/rkyv/0.7.1/rkyv/trait.ArchiveUnsized.html"><code>ArchiveUnsized</code></a>,
<a href="https://docs.rs/rkyv/0.7.1/rkyv/trait.SerializeUnsized.html"><code>SerializeUnsized</code></a>, and
<a href="https://docs.rs/rkyv/0.7.1/rkyv/trait.DeserializeUnsized.html"><code>DeserializeUnsized</code></a>.</p>
<blockquote>
<p>A good way to think about it is that sized types are the <em>foundation</em> that unsized types are built
on. That's not a fluke either, rkyv is built precisely so that you can build more complex
abstractions out of lower-level machinery in a safe and composable way. It's not much different
from what you normally do while programming!</p>
</blockquote>
<p>The system is built to be flexible and can be extended beyond the provided types. For example, the
<code>rkyv_dyn</code> crate adds support for trait objects by introducing new traits and defining how they
build up to allow trait objects to be serialized and deserialized.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relative-pointers"><a class="header" href="#relative-pointers">Relative pointers</a></h1>
<p>Relative pointers are the bread and butter of total zero-copy deserialization, completely replacing
the use of normal pointers. But why can't we use normal pointers?</p>
<p>Consider some zero-copy data on disc. Before we can use it, we need to load it into memory. But we
can't control <em>where</em> in memory it gets loaded. Every time we load it, it could be located at a
different address, and therefore the objects inside of it will be located at a different address.</p>
<blockquote>
<p>One of the major reasons for this is actually <em>security</em>. Every time you run your program, it may
run in a completely different random location in memory. This is called
<a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">address space layout randomization</a>
and it helps prevent exploitation of memory corruption vulnerabilities.</p>
<p>At most, we can only control the <em>alignment</em> of our zero-copy data, so we need to work within
those constraints.</p>
</blockquote>
<p>This means that we can't store any pointers to that data, inside of it or outside of it. As soon as
we reload the data, it might not be at the same address. That would leave our pointers dangling, and
would almost definitely result in memory access violations. Some other libraries like
<a href="https://github.com/TimelyDataflow/abomonation">abomonation</a> store some extra data and perform a
fast fixup step that takes the place of deserialization, but we can do better.</p>
<blockquote>
<p>In order to perform that fixup step, abomonation requires that the buffer has a <em>mutable backing</em>.
This is okay for many use cases, but there are also cases where we won't be able to mutate our
buffer. One example is if we used
<a href="https://en.wikipedia.org/wiki/Memory-mapped_file">memory-mapped files</a>.</p>
</blockquote>
<p>While normal pointers hold an absolute address in memory, relative pointers hold an offset to an address. This changes how
the pointer behaves under moves:</p>
<div class="table-wrapper"><table><thead><tr><th>Pointer</th><th>Self is moved</th><th>Self and target are moved</th></tr></thead><tbody>
<tr><td>Absolute</td><td>✅ Target is still at address</td><td>❌ Target no longer at address</td></tr>
<tr><td>Relative</td><td>❌ Relative distance has changed</td><td>✅ Self and target same relative distance apart</td></tr>
</tbody></table>
</div>
<p>This is exactly the property we need to build data structures with total zero-copy deserialization.
By using relative pointers, we can load data at any position in memory and still have valid pointers
inside of it. Relative pointers don't require write access to memory either, so we can memory map
entire files and instantly have access to their data in a structured manner.</p>
<p>rkyv's implementation of relative pointers is the
<a href="https://docs.rs/rkyv/0.7.1/rkyv/rel_ptr/struct.RelPtr.html"><code>RelPtr</code></a> type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="archive"><a class="header" href="#archive">Archive</a></h1>
<p>Types that implement <code>Archive</code> have an alternate representation that supports zero-copy
deserialization. The construction of archived types happens in two steps:</p>
<ol>
<li>Any dependencies of the type are serialized. For strings this would be the characters of the
string, for boxes it would be the boxed value, and for vectors it would be any contained elements.
Any bookkeeping from this step is bundled into a <code>Resolver</code> type and held onto for later. This is
the <em>serialize</em> step.</li>
<li>The resolver and original value are used to construct the archived value in the output buffer.
For strings the resolver would be the position of the characters, for boxes it would be the position
of the boxed value, and for vectors it would be the position of the archived elements. With the
original values and resolvers combined, the archived version can be constructed. This is the
<em>resolve</em> step.</li>
</ol>
<h2 id="resolvers"><a class="header" href="#resolvers">Resolvers</a></h2>
<p>A good example of why resolvers are necessary is when archiving a tuple. Say we have two strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = (&quot;hello&quot;.to_string(), &quot;world&quot;.to_string());
<span class="boring">}</span></code></pre></pre>
<p>The archived tuple needs to have both of the strings right next to each other:</p>
<pre><code>0x0000      AA AA AA AA BB BB BB BB
0x0008      CC CC CC CC DD DD DD DD
</code></pre>
<p>A and B might be the length and pointer for the first string of the tuple, and C and D might be the
length and pointer for the second string.</p>
<p>When archiving, we might be tempted to serialize and resolve the first string, then serialize and
resolve the second one. But this might place the second string's bytes (&quot;world&quot;) between the two!
Instead, we need to write out the bytes for both strings, and then finish archiving both of them.
The tuple doesn't know what information the strings need to finish archiving themselves, so they
have to provide it to the tuple through their Resolver.</p>
<p>This way, the tuple can:</p>
<ol>
<li>Archive the first string (save the resolver)</li>
<li>Archive the second string (save the resolver)</li>
<li>Resolve the first string with its resolver</li>
<li>Resolve the second string with its resolver</li>
</ol>
<p>And we're guaranteed that the two strings are placed right next to each other like we need.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialize"><a class="header" href="#serialize">Serialize</a></h1>
<p>Types implement <a href="https://docs.rs/rkyv/0.7.1/rkyv/trait.Serialize.html"><code>Serialize</code></a> separately from
<code>Archive</code>. <code>Serialize</code> creates a resolver for some object, then <code>Archive</code> turns the value and that
resolver into an archived type. Having a separate <code>Serialize</code> trait is necessary because although a
type may have only one archived representation, you may have options of what requirements to meet in
order to create one.</p>
<blockquote>
<p>The <code>Serialize</code> trait is parameterized over the <em>serializer</em>. The serializer is just a mutable
object that helps the type serialize itself. The most basic types like <code>u32</code> or <code>char</code> don't
<em>bound</em> their serializer type because they can serialize themselves with any kind of serializer.
More complex types like <code>Box</code> and <code>String</code> require a serializer that implements
<a href="https://docs.rs/rkyv/0.7.1/rkyv/ser/trait.Serializer.html"><code>Serializer</code></a>, and even more complex
types like <code>Rc</code> and <code>Vec</code> require a serializer that additionally implement
<a href="https://docs.rs/rkyv/0.7.1/rkyv/ser/trait.SharedSerializeRegistry.html"><code>SharedSerializeRegistry</code></a>
or <a href="https://docs.rs/rkyv/0.7.1/rkyv/ser/trait.ScratchSpace.html"><code>ScratchSpace</code></a>.</p>
</blockquote>
<p>Unlike <code>Serialize</code>, <code>Archive</code> doesn't parameterize over the serializer used to make it. It shouldn't
matter what serializer a resolver was made with, only that it's made correctly.</p>
<h2 id="serializer"><a class="header" href="#serializer">Serializer</a></h2>
<p>rkyv provides serializers that provide all the functionality needed to serialize standard library
types, as well as serializers that combine other serializers into a single object with all of the
components' capabilities.</p>
<p>The <a href="https://docs.rs/rkyv/0.7.1/rkyv/ser/serializers/index.html">provided serializers</a> offer a wide
range of strategies and capabilities, but most use cases will be best suited by
<a href="https://docs.rs/rkyv/0.7.1/rkyv/ser/serializers/type.AllocSerializer.html"><code>AllocSerializer</code></a>.</p>
<blockquote>
<p>Many types require <em>scratch space</em> to serialize. This is some extra allocated space that they can
use temporarily and return when they're done. For example, <code>Vec</code> might request scratch space to
store the resolvers for its elements until it can serialize all of them. Requesting scratch space
from the serializer allows scratch space to be reused many times, which reduces the number of slow
memory allocations performed while serializing.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deserialize"><a class="header" href="#deserialize">Deserialize</a></h1>
<p>Similarly to <code>Serialize</code>, <a href="https://docs.rs/rkyv/0.7.1/rkyv/trait.Deserialize.html"><code>Deserialize</code></a>
parameterizes over and takes a deserializer, and converts a type from its archived form back to its
original one. Unlike serialization, deserialization occurs in a single step and doesn't have an
equivalent of a resolver.</p>
<blockquote>
<p><code>Deserialize</code> also parameterizes over the type that is being deserialized into. This allows the
same archived type to deserialize into multiple different unarchived types depending on what's
being asked for. This helps enable lots of very powerful abstractions, but might require you to
annoate types when deserializing.</p>
</blockquote>
<p>This provides a more or less a traditional deserialization with the added benefit of being sped up
somewhat by having very compatible representations. It also incurs both the memory and performance
penalties of traditional deserialization, so make sure that it's what you need before you use it.
Deserialization is not required to access archived data as long as you can do so through the
archived versions.</p>
<blockquote>
<p>Even the highest-performance serialization frameworks will hit a deserialization speed limit
because of the amount of memory allocation that needs to be performed.</p>
</blockquote>
<p>A good use for <code>Deserialize</code> is deserializing portions of archives. You can easily traverse the
archived data to locate some subobject, then deserialize just that piece instead of the archive as a
whole. This granular approach provides the benefits of both zero-copy deserialization as well as
traditional deserialization.</p>
<h2 id="deserializer"><a class="header" href="#deserializer">Deserializer</a></h2>
<p>Deserializers, like serializers, provide capabilities to objects during deserialization. Most types
don't bound their deserializers, but some like <code>Rc</code> require special deserializers in order to
deserialize memory properly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alignment"><a class="header" href="#alignment">Alignment</a></h1>
<p>The <em>alignment</em> of a type restricts where it can be located in memory to optimize hardware loads and
stores. Because rkyv creates references to values located in your serialized bytes, it has to ensure
that the references it creates are properly <em>aligned</em> for the type.</p>
<blockquote>
<p>In order to perform arithmetic and logical operations on data, modern CPUs need to <em>load</em> that
data from memory into its registers. However, there's usually a hardware limitation on how the CPU
can access that data: it can only access data starting at <em>word boundaries</em>. These words are the
natural size for the CPU to work with; the word size is 4 bytes for 32-bit machines and 8 bytes
for 64-bit machines. Imagine we had some data laid out like this:</p>
<pre><code>0   4   8   C
AAAABBBBCCCCDDDD
</code></pre>
<p>On a 32-bit CPU, accesses could occur at any address that's a multiple of 4 bytes. For example,
one could access <code>A</code> by loading 4 bytes from address 0, <code>B</code> by loading 4 bytes from address 4, and
so on. This works great because our data is <em>aligned</em> to word boundaries. <em>Unaligned</em> data can
throw a wrench in that:</p>
<pre><code>0   4   8   C
..AAAABBBBCCCC
</code></pre>
<p>Now if we want to load <code>A</code> into memory, we have to:</p>
<ol>
<li>Load 4 bytes from address 0</li>
<li>Throw away the first two bytes</li>
<li>Load 4 bytes from address 4</li>
<li>Throw away the last two bytes</li>
<li>Combine our four bytes together</li>
</ol>
<p>That forces us to do twice as many loads <em>and</em> perform some correction logic. That can have a real
impact on our performance across the board, so we require all of our data to be properly aligned.</p>
</blockquote>
<p>rkyv provides two main utilities for aligning byte buffers:</p>
<ul>
<li><a href="https://docs.rs/rkyv/latest/rkyv/util/struct.AlignedVec.html"><code>AlignedVec</code></a> is a drop-in
replacement for <code>Vec&lt;u8&gt;</code></li>
<li><a href="https://docs.rs/rkyv/latest/rkyv/util/struct.AlignedBytes.html"><code>AlignedBytes</code></a> is a wrapper
around <code>[u8; N]</code></li>
</ul>
<p>Both of these types align the bytes inside to 16-byte boundaries. This should be enough for almost
all use cases, but if your particular situation requires even higher alignment then you may need to
manually align your bytes.</p>
<h2 id="in-practice"><a class="header" href="#in-practice">In practice</a></h2>
<p>rkyv has a very basic unaligned data check built in that may not catch every case. If you also
<a href="architecture/../validation.html">validate</a> your data, then it will always make sure that your data is properly
aligned.</p>
<h3 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common pitfalls</a></h3>
<p>In some cases, your archived data may be prefixed by some extra data like the length of the buffer.
If this extra data misaligns the following data, then the buffer will have to have the prefixing
data removed before accessing it.</p>
<p>In other cases, your archived data may not be tight to the end of the buffer. Functions like
<a href="https://docs.rs/rkyv/latest/rkyv/util/fn.archived_root.html"><code>archived_root</code></a> rely on the end of
the buffer being tight to the end of the data, and may miscalculate the positions of the contained
values if it is not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format"><a class="header" href="#format">Format</a></h1>
<p>Types which derive <code>Archive</code> generate an archived version of the type where:</p>
<ul>
<li>Member types are replaced with their archived counterparts</li>
<li>Enums have <code>#[repr(N)]</code> where N is <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, or <code>u128</code>, choosing the smallest
possible type that can represent all of the variants.</li>
</ul>
<p>For example, a struct like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Example {
    a: u32,
    b: String,
    c: Box&lt;(u32, String)&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Would have the archived counterpart:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ArchivedExample {
    a: u32,
    b: ArchivedString,
    c: ArchivedBox&lt;(u32, ArchivedString)&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>With the <code>strict</code> feature, these structs are additionally annotated with <code>#[repr(C)]</code> for guaranteed
portability and stability.</p>
<blockquote>
<p>In most cases, the <code>strict</code> feature will not be necessary and can reduce the space efficiency of
archived types. Make sure you understand your use case carefully and read the crate documentation
for details on the <code>strict</code> feature.</p>
</blockquote>
<p>rkyv provides <code>Archive</code> implementations for common core and std types by default. In general they
follow the same format as derived implementations, but may differ in some cases. For example,
<code>ArchivedString</code> performs a small string optimization which helps reduce memory use.</p>
<h2 id="object-order"><a class="header" href="#object-order">Object order</a></h2>
<p>rkyv lays out subobjects in depth-first order from the leaves to the root. This means that the root
object is stored at the end of the buffer, not the beginning. For example, this tree:</p>
<pre><code>  a
 / \
b   c
   / \
  d   e
</code></pre>
<p>would be laid out like this in the buffer:</p>
<pre><code>b d e c a
</code></pre>
<p>from this serialization order:</p>
<pre><code>a -&gt; b
a -&gt; c -&gt; d
a -&gt; c -&gt; e
a -&gt; c
a
</code></pre>
<p>This deterministic layout means that you don't need to store the position of the root object in most
cases. As long as your buffer ends right at the end of your root object, you can use
<a href="https://docs.rs/rkyv/0.7.1/rkyv/util/fn.archived_root.html"><code>archived_root</code></a> with your buffer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapper-types"><a class="header" href="#wrapper-types">Wrapper types</a></h1>
<p>Wrapper types make it easy to customize the way that fields of types are archived. They make it
easier to adapt rkyv to existing data models, and make serializing and deserializing idiomatic for
even complicated types.</p>
<p>Annotating a field with <code>#[with(...)]</code> will <em>wrap</em> that field with the given types when the struct
is serialized or deserialized. There's no performance penalty to actually wrap types, but doing more
or less work during serialization and deserialization can affect performance. This excerpt is from
the documentation for <a href="https://docs.rs/rkyv/0.7.1/rkyv/with/trait.ArchiveWith.html"><code>ArchiveWith</code></a>:</p>
<pre><code class="language-rs">#[derive(Archive, Deserialize, Serialize)]
struct Example {
    #[with(Incremented)]
    a: i32,
    // Another i32 field, but not incremented this time
    b: i32,
}
</code></pre>
<p>The <code>Incremented</code> wrapper is wrapping <code>a</code>, and the definition causes that field to be incremented
in its archived form. </p>
<h2 id="with"><a class="header" href="#with"><code>With</code></a></h2>
<p>The core type behind wrappers is <a href="https://docs.rs/rkyv/0.7.1/rkyv/with/struct.With.html"><code>With</code></a>.
This struct is <em>transparent</em>, meaning that it's like another name for the type inside of it. rkyv
uses <code>With</code> to wrap your fields when serializing and deserializing, and when you write your own
wrappers they will be used with <code>With</code> as well.</p>
<p>See <a href="https://docs.rs/rkyv/0.7.1/rkyv/with/trait.ArchiveWith.html"><code>ArchiveWith</code></a> for an example of how
to write your own wrapper types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-pointers"><a class="header" href="#shared-pointers">Shared Pointers</a></h1>
<p>The implementation details of shared pointers may be of interest to those using them. Specifically,
the rules surrounding how and when shared and weak pointers are serialized and pooled may affect how
you choose to use them.</p>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<p>Shared pointers (<code>Rc</code> and <code>Arc</code>) are serialized whenever they're encountered for the first time, and
the data address is reused when subsequent shared pointers point to the same data. This means that
you can expect shared pointers to always point to the same value when archived, even if they are
unsized to different types.</p>
<p>Weak pointers (<code>rc::Weak</code> and <code>sync::Weak</code>) have serialization attempted as soon as they're
encountered. The serialization process upgrades them, and if it succeeds it serializes them like
shared pointers. Otherwise, it serializes them like <code>None</code>.</p>
<h2 id="deserialization"><a class="header" href="#deserialization">Deserialization</a></h2>
<p>Similarly, shared pointers are deserialized on the first encounter and reused afterward. Weak
pointers do a similar upgrade attempt when they're encountered for the first time.</p>
<h2 id="serializers-and-deserializers"><a class="header" href="#serializers-and-deserializers">Serializers and Deserializers</a></h2>
<p>The serializers for shared pointers hold the location of the serialized data. This means it's safe
to serialize shared pointers to an archive across multiple <code>serialize</code> calls as long as you use the
same serializer for each one. Using a new serializer will still do the right thing, but may end up
duplicating the shared data.</p>
<p>The deserializers for shared pointers hold a shared pointer to any deserialized values, and will
hold them in memory until the deserializer is dropped. This means that if you serialize only weak
pointers to some shared data, they will point to the correct value when deserialized but will point
to nothing as soon as the deserializer is dropped.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsized-types"><a class="header" href="#unsized-types">Unsized Types</a></h1>
<p>rkyv supports unsized types out of the box and ships with implementations for the most common
unsized types (<code>str</code>s and slices). Trait objects can also be supported with <code>rkyv_dyn</code>, see
<a href="trait-objects.html">&quot;Trait Objects&quot;</a> for more details.</p>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>The core concept that enables unsized types is metadata. In rust, pointers to types can be different
sizes, in contrast with languages like C and C++ where all pointers are the same size. This is
important for the concept of sizing, which you may have encountered through rust's
<a href="https://doc.rust-lang.org/std/marker/trait.Sized.html">Sized</a> trait.</p>
<p>Pointers are composed of two pieces: a data address and some metadata. The data address is what most
people think of when they think about pointers; it's the location of the pointed data. The metadata
for a pointer is some extra data that is needed to work safely with the data at the pointed
location. It can be almost anything, or nothing at all for <code>Sized</code> types. Pointers with no extra
metadata are sometimes called &quot;thin&quot; pointers, and pointers <em>with</em> metadata are sometimes called
&quot;wide&quot; or &quot;fat&quot; pointers.</p>
<blockquote>
<p>rkyv uses the <a href="https://docs.rs/ptr_meta"><code>ptr_meta</code></a> crate to perform these conversions safely. In
the future, these may be incorporated as
<a href="https://rust-lang.github.io/rfcs/2580-ptr-meta.html">part of the standard library</a>.</p>
</blockquote>
<p>Fundamentally, the metadata of a pointer exists to provide the program enough information to safely
access, drop, and deallocate structures that are pointed to. For slices, the metadata carries the
length of the slice, for trait objects it carries the virtual function table (vtable) pointer, and
for custom unsized structs it carries the metadata of the single trailing unsized member.</p>
<h2 id="archived-metadata"><a class="header" href="#archived-metadata">Archived Metadata</a></h2>
<p>For unsized types, the metadata for a type is archived separately from the relative pointer to the
data. This mirrors how rust works internally to support archiving shared pointers and other exotic
use cases. This does complicate things somewhat, but for most people the metadata archiving process
will end up as just filling out a few functions and returning <code>()</code>.</p>
<blockquote>
<p>This is definitely one of the more complicated parts of the library, and can be difficult to wrap
your head around. Reading the documentation for
<a href="https://docs.rs/rkyv/0.7.1/rkyv/trait.ArchiveUnsized.html"><code>ArchiveUnsized</code></a> may help you
understand how the system works by working through an example.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-objects"><a class="header" href="#trait-objects">Trait Objects</a></h1>
<p>Trait object serialization is supported through the <code>rkyv_dyn</code> crate. This crate is maintained as
part of rkyv, but is separate from the main crate to allow other implementations to be used instead.
This section will focus primarily on the architecture of <code>rkyv_dyn</code> and how to use it effectively.</p>
<blockquote>
<p><code>rkyv_dyn</code> may not work in some exotic environments due to the ✨magic✨ it uses to register
trait objects. If you want these capabilities but <code>rkyv_dyn</code> doesn't work in your environment,
feel free to file an issue or drop by in the discord to talk it through.</p>
</blockquote>
<h2 id="core-traits"><a class="header" href="#core-traits">Core traits</a></h2>
<p>The new traits introduced by <code>rkyv_dyn</code> are
<a href="https://docs.rs/rkyv_dyn/latest/rkyv_dyn/trait.SerializeDyn.html"><code>SerializeDyn</code></a> and
<a href="https://docs.rs/rkyv_dyn/latest/rkyv_dyn/trait.DeserializeDyn.html"><code>DeserializeDyn</code></a>. These are
effectively type-erased versions of <code>SerializeUnsized</code> and <code>DeserializeUnsized</code> so that the traits
are object-safe. Likewise, it introduces type-erased versions of serializers and deserializers:
<a href="https://docs.rs/rkyv_dyn/latest/rkyv_dyn/trait.DynSerializer.html"><code>DynSerializer</code></a> and
<a href="https://docs.rs/rkyv_dyn/latest/rkyv_dyn/trait.DynDeserializer.html"><code>DynDeserializer</code></a>. These
attempt to provide the basic functionality required to serialize most types, but may be more or less
capable than custom types require.</p>
<blockquote>
<p><code>DynSerializer</code> implements the <code>Serializer</code> and <code>ScratchSpace</code> traits, but that may not be
suitable for all use cases. If you need more capabilities, file an issue or drop by in the discord
to talk it through.</p>
</blockquote>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<p>It is highly recommended to use the provided
<a href="https://docs.rs/rkyv_dyn/latest/rkyv_dyn/attr.archive_dyn.html"><code>archive_dyn</code></a> macro to implement
the new traits and set everything up correctly.</p>
<p>Using <code>archive_dyn</code> on a trait definition creates another trait definition with supertraits of your
trait and <code>SerializeDyn</code>. This &quot;shim&quot; trait is blanket implemented for all types that implement your
trait and <code>SerializeDyn</code>, so you should only ever have to implement your trait to use it.</p>
<p>The shim trait should be used everywhere that you have a trait object of your trait that you want to
serialize. By default, it will be named &quot;Serialize&quot; + your trait name. A different approach that
similar libraries take is directly adding <code>SerializeDyn</code> as a supertrait of your trait. While more
ergonomic, this approach does not allow the implementation of the trait on types that cannot or
should not implement <code>SerializeDyn</code>, so the shim trait approach was favored for <code>rkyv_dyn</code>.</p>
<p>When the shim trait is serialized, it stores the type hash of the underlying type in its metadata so
it can get the correct vtable for it when accessed. This requires that all vtables for implementing
types must be known ahead of time, which is when we use <code>archive_dyn</code> for the second time.</p>
<p>Using <code>archive_dyn</code> on a trait implementation registers the vtable for that implementation with a
global lookup, allowing it to be retrieved later on. Because this process can be slow, the
<code>vtable_cache</code> feature allows the vtable lookup to be performed only the first time, then cached
locally for future lookups. This is one of the places where alternate implementations may take a
different approach and choose a different set of benefits and tradeoffs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation"><a class="header" href="#validation">Validation</a></h1>
<p>Validation can be enabled with the <code>validation</code> feature. Validation leverages the
<a href="https://docs.rs/bytecheck"><code>bytecheck</code></a> crate to perform archive validation, and allows the
consumption of untrusted and malicious data.</p>
<p>To validate an archive, you first have to derive
<a href="https://docs.rs/bytecheck/latest/bytecheck/trait.CheckBytes.html"><code>CheckBytes</code></a> for your archived
type:</p>
<pre><code class="language-rs">use rkyv::{Archive, Deserialize, Serialize};

#[derive(Archive, Deserialize, Serialize)]
#[archive(check_bytes)]
pub struct Example {
    a: i32,
    b: String,
    c: Vec&lt;bool&gt;,
}
</code></pre>
<p>The <code>#[archive(check_bytes)]</code> attribute derives <code>CheckBytes</code> on the archived type. Finally, you can use
<a href="https://docs.rs/rkyv/0.7.1/rkyv/validation/validators/fn.check_archived_root.html"><code>check_archived_root</code></a> to
check an archive and get a reference to the archived value if it was successful:</p>
<pre><code class="language-rs">use rkyv::check_archived_root;

let archived_example = check_archived_root::&lt;Example&gt;(buffer).unwrap();
</code></pre>
<p>More examples of how to enable and perform validation can be found in the <code>rkyv_test</code> crate's
<code>validation</code> module.</p>
<h2 id="the-validation-context"><a class="header" href="#the-validation-context">The validation context</a></h2>
<p>When checking an archive, a validation context is created automatically using some good defaults
that will work for most archived types. If your type requires special validation logic, you may need
to augment the capabilities of the validation context in order to check your type and use
<a href="https://docs.rs/rkyv/0.7.1/rkyv/validation/fn.check_archived_root_with_context.html"><code>check_archived_root_with_context</code></a>.</p>
<blockquote>
<p>The
<a href="https://docs.rs/rkyv/latest/rkyv/validation/validators/struct.DefaultValidator.html"><code>DefaultValidator</code></a>
supports all builtin rkyv types, but changes depending on whether you have the <code>alloc</code> feature
enabled or not.</p>
</blockquote>
<h2 id="bounds-checking-and-subtree-ranges"><a class="header" href="#bounds-checking-and-subtree-ranges">Bounds checking and subtree ranges</a></h2>
<p>All pointers are checked to make sure that they:</p>
<ul>
<li>point inside the archive</li>
<li>are properly aligned</li>
<li>and have enough space afterward to hold the desired object</li>
</ul>
<p>However, this alone is not enough to secure against recursion attacks and memory sharing violations,
so rkyv uses a system to verify that the archive follows its strict ownership model.</p>
<p>Archive validation uses a memory model where all subobjects are located in contiguous memory. This
is called a <em>subtree range</em>. When validating an object, the archive context keeps track of where
subobjects are allowed to be located, and can reduce the subtree range from the beginning with
<code>push_prefix_subtree_range</code> or the end with <code>push_suffix_subtree_range</code>. After pushing a subtree
range, any subobjects in that range can be checked by calling their <code>CheckBytes</code> implementations.
Once the subobjects are checked, <code>pop_prefix_subtree_range</code> and <code>pop_suffix_subtree_range</code> can be
used to restore the original range with the checked section removed.</p>
<h2 id="validation-and-shared-pointers"><a class="header" href="#validation-and-shared-pointers">Validation and Shared Pointers</a></h2>
<p>While validating shared pointers is supported, some additional restrictions are in place to prevent
malicious data from validating:</p>
<p>Shared pointers that point to the same object will fail to validate if they are different types.
This can cause issues if you have a shared pointer to the same array, but the pointers are an array
pointer and a slice pointer. Similarly, it can cause issues if you have shared pointers to the same
value as a concrete type (e.g. <code>i32</code>) and a trait object (e.g. <code>dyn Any</code>).</p>
<p>rkyv still supports these use cases, but it's not possible or feasible to ensure data integrity with
these use cases. Alternative validation solutions like archive signatures and data hashes may be a
better approach in these cases.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-comparison"><a class="header" href="#feature-comparison">Feature Comparison</a></h1>
<p>This is a best-effort feaure comparison between rkyv, FlatBuffers, and Cap'n Proto. This is by no
means completely comprehensive, and pull requests that improve this are welcomed.</p>
<h2 id="feature-matrix"><a class="header" href="#feature-matrix">Feature matrix</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>rkyv</th><th>Cap'n Proto</th><th>FlatBuffers</th></tr></thead><tbody>
<tr><td>Open type system</td><td>yes</td><td>no</td><td>no</td></tr>
<tr><td>Scalars</td><td>yes</td><td>no</td><td>yes</td></tr>
<tr><td>Tables</td><td>no*</td><td>yes</td><td>yes</td></tr>
<tr><td>Schema evolution</td><td>no*</td><td>yes</td><td>yes</td></tr>
<tr><td>Zero-copy</td><td>yes</td><td>yes</td><td>yes</td></tr>
<tr><td>Random-access reads</td><td>yes</td><td>yes</td><td>yes</td></tr>
<tr><td>Validation</td><td>upfront*</td><td>on-demand</td><td>yes</td></tr>
<tr><td>Reflection</td><td>no*</td><td>yes</td><td>yes</td></tr>
<tr><td>Object order</td><td>bottom-up</td><td>either</td><td>bottom-up</td></tr>
<tr><td>Schema language</td><td>derive</td><td>custom</td><td>custom</td></tr>
<tr><td>Usable as mutable state</td><td>yes</td><td>limited</td><td>limited</td></tr>
<tr><td>Padding takes space on wire?</td><td>yes*</td><td>optional</td><td>no</td></tr>
<tr><td>Unset fields take space on wire?</td><td>yes</td><td>yes</td><td>no</td></tr>
<tr><td>Pointers take space on wire?</td><td>yes</td><td>yes</td><td>yes</td></tr>
<tr><td>Cross-language</td><td>no</td><td>yes</td><td>yes</td></tr>
<tr><td>Hash maps and B-trees</td><td>yes</td><td>no</td><td>no</td></tr>
<tr><td>Shared pointers</td><td>yes</td><td>no</td><td>no</td></tr>
</tbody></table>
</div>
<p>* <em>rkyv's open type system allows extension types that provide these capabilities</em></p>
<h2 id="open-type-system"><a class="header" href="#open-type-system">Open type system</a></h2>
<p>One of rkyv's primary features is that its type system is <em>open</em>. This means that users can write
custom types and control their properties very finely. You can think of rkyv as a solid foundation
to build many other features on top of. In fact, the open type system is already a fundamental part
of how rkyv works.</p>
<h3 id="unsized-types-1"><a class="header" href="#unsized-types-1">Unsized types</a></h3>
<p>Even though they're part of the main library, unsized types are built on top of the core
serialization functionality. Types like <code>Box</code> and <code>Rc/Arc</code> that can hold unsized types are entry
points for unsized types into the sized system.</p>
<h3 id="trait-objects-1"><a class="header" href="#trait-objects-1">Trait objects</a></h3>
<p>Trait objects are further built on top of unsized types to make serializing and using trait objects
easy and safe.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<p>Because it's so different from traditional serialization systems, a lot of people have questions
about rkyv. This is meant to serve as a comprehensive, centralized source for answers.</p>
<h2 id="how-is-rkyv-zero-copy-it-definitely-copies-the-archive-into-memory"><a class="header" href="#how-is-rkyv-zero-copy-it-definitely-copies-the-archive-into-memory">How is rkyv zero-copy? It definitely copies the archive into memory.</a></h2>
<p>Traditional serialization works in two steps:</p>
<ol>
<li>Read the data from disk into a buffer (maybe in pieces)</li>
<li>Process the data in the buffer into the deserialized data structure</li>
</ol>
<p>The copy happens when the data in the buffer ends up duplicated in the data structure. Zero-copy
deserialization doesn't deserialize the buffer into a separate structure and thus avoids this copy.</p>
<p>You can actually even avoid reading the data from disk into a buffer in most environments by using
memory mapping.</p>
<h2 id="how-does-rkyv-handle-endianness"><a class="header" href="#how-does-rkyv-handle-endianness">How does rkyv handle endianness?</a></h2>
<p>rkyv supports three endiannesses: native, little, and big. Native endianness will be either little
or big, but removes the abstraction layer to more easily work with the underlying types.</p>
<p>You can enable specific endiannesses with the <code>archive_le</code> and <code>archive_be</code> features.</p>
<h2 id="is-rkyv-cross-platform"><a class="header" href="#is-rkyv-cross-platform">Is rkyv cross-platform?</a></h2>
<p>Yes, but rkyv has been tested mostly on x86 machines and wasm. There may be bugs that need to get
fixed for other architectures.</p>
<h2 id="can-i-use-this-in-embedded-and-no_std-environments"><a class="header" href="#can-i-use-this-in-embedded-and-no_std-environments">Can I use this in embedded and <code>#[no_std]</code> environments?</a></h2>
<p>Yes, disable the <code>std</code> feature for <code>no_std</code>. You can additionally disable the <code>alloc</code> feature to
disable all memory allocation capabilities.</p>
<h1 id="safety"><a class="header" href="#safety">Safety</a></h1>
<h2 id="isnt-this-very-unsafe-if-you-access-untrusted-data"><a class="header" href="#isnt-this-very-unsafe-if-you-access-untrusted-data">Isn't this very unsafe if you access untrusted data?</a></h2>
<p>Yes, <em>but</em> you can still access untrusted data if you validate the archive first with
<a href="https://github.com/rkyv/bytecheck">bytecheck</a>. It's an extra step, but it's usually still less
than the cost of deserializing using a traditional format. rkyv has proven to round-trip faster than
bincode for all tested use cases.</p>
<h2 id="doesnt-that-mean-i-always-have-to-validate"><a class="header" href="#doesnt-that-mean-i-always-have-to-validate">Doesn't that mean I always have to validate?</a></h2>
<p><strong>No</strong>. There are many other ways you can verify your data, for example with checksums and signed
buffers.</p>
<h2 id="isnt-it-kind-of-deceptive-to-say-rkyv-is-fast-and-then-require-validation"><a class="header" href="#isnt-it-kind-of-deceptive-to-say-rkyv-is-fast-and-then-require-validation">Isn't it kind of deceptive to say rkyv is fast and then require validation?</a></h2>
<p>The fastest path to access archived data is marked as <code>unsafe</code>. This doesn't mean that it's
unusable, it means that it's only safe to call if you can verify its preconditions:</p>
<blockquote>
<p>The value must be archived at the given position in the byte array.</p>
</blockquote>
<p>As long as you can (reasonably) guarantee that, then accessing the archive is safe. Not every
archive needs to be validated, and you can use a variety of different techniques to guarantee data
integrity and security.</p>
<p>Even if you do need to always validate your data before accessing it, validation is always faster
than deserializing with other high-performance formats. A round-trip is still faster, even though
it's not by the same margins.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Thanks to all the contributors who have helped document rkyv:</p>
<ul>
<li>David Koloski (<a href="https://github.com/djkoloski">djkoloski</a>)</li>
</ul>
<p>If you feel you're missing from this list, feel free to add yourself in a PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
